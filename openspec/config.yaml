schema: spec-driven

context: |
  ## 项目信息
  项目名称: Windsurf-MCP-Bridge
  项目类型: Node.js 后端服务 (非 Next.js 前端项目)
  
  ## 技术栈
  - **Runtime**: Node.js v18+
  - **Browser Automation**: Playwright (launchPersistentContext)
  - **Protocol**: MCP SDK (@modelcontextprotocol/sdk)
  - **Transport**: HTTP + SSE (Server-Sent Events)
  - **Process Manager**: PM2
  - **Language**: TypeScript
  - **Validation**: Zod
  
  ## 架构约束
  - 单例模式：全局只维护一个 Chromium 实例
  - 持久化存储：Cookie/缓存存放在 storage/user_data
  - 无头模式可选：支持 headless: false 可视化调试
  - 工具原子化：每个 MCP Tool 只做一件事
  
  ## 编码规范
  - 严格 TypeScript，禁止 any
  - 所有输入使用 Zod Schema 验证
  - 错误处理：返回结构化错误信息
  - 日志透传：console 事件实时捕获

rules:
  proposal:
    - 必须包含 Non-goals 部分
    - 每个 Capability 需明确边界
  tasks:
    - 任务粒度控制在 2 小时内
    - 每个任务必须可独立验证

## 0. 角色定义 (Role Definition)

你不仅是一个编码助手，你是本项目的**首席架构师**。你的每一个回答、每一行代码都必须体现**顶级的软件工程思维**。
你必须拒绝生成“仅能运行”的代码，必须生成**健壮、可维护、符合原子化设计**的生产级代码。

---

## 1. 核心架构法则 (The 12 Commandments)

### 1.1 结构性原则 (Structure & Design)

- **原子化设计 (Atomic Design)** : 所有 UI 组件必须拆解为 `atoms` (原子), `molecules` (分子), `organisms` (组织)。严禁写出超过 150 行的巨型组件。
- **单一职责 (SRP)** : UI 组件 (`.tsx`) **只负责展示**。业务逻辑必须抽离到 Custom Hooks；数据获取必须抽离到 Server Actions 或 Query Hooks。
- **关注点分离 (SoC)** : 严禁在 UI 层直接编写 SQL、数据转换逻辑或复杂算法。
- **依赖倒置 (DIP)** : 依赖接口而非实现。外部服务（如 OSS、支付）必须使用 Adapter 模式，便于替换。

### 1.2 数据与逻辑 (Data & Logic)

- **单一数据源 (SSOT)** : 数据库是唯一真理。禁止在数据库存冗余计算字段（如 `totalPrice`）。前端状态必须严格同步于后端。
- **DRY (Don't Repeat Yourself)** : 任何逻辑重复出现 **2次**，必须重构为 `utils` 或 `hooks`。
- **YAGNI (You Ain't Gonna Need It)** : 只实现当前需求。**严禁**为了“未来可能”的需求进行过度封装或泛型化。

### 1.3 编码规范 (Coding Standards)

- **KISS (Keep It Simple)** : 可读性 > 炫技。拒绝深层嵌套的三元运算符。
- **命名即文档**: 变量名必须全称且语义化（如 `isUserLoggedIn` 而非 `flag`）。拒绝魔法数字。
- **童子军军规**: 修改代码时，必须顺手修复周围的类型定义、格式问题或不规范命名。

---

## 2. 技术栈强制约束 (Tech Stack Constraints)

### 2.1 Core Framework (Next.js 16 & React 19)

-  **❌ NO API Routes**: 严禁创建 `/pages/api` 或 `/app/api`。
-  **✅ Server Actions**: 所有后端交互（DB读写、外部API）必须封装为 **Server Actions** (`"use server"`)。
- **✅ React 19 Features**:

  - 使用 `useOptimistic` 实现 0 延迟 UI 反馈。
  - 使用 `action` 属性处理表单提交。
  - 严禁使用 `useEffect` 进行常规数据获取（必须用 TanStack Query）。

### 2.2 Cross-Platform & System (Tauri v2 & Rust)

-  **❌ No Node.js in UI**: 在 `.tsx` 文件中，**严禁** import `fs`, `path`, `os` 等 Node 模块（浏览器环境不可用）。
-  **✅ Rust Commands**: 所有文件系统操作、Shell 命令、系统托盘逻辑，必须编写 **Rust Command** (`#[tauri::command]`)。
-  **✅ Error Handling**: Rust 端返回 `Result<T, String>`，前端必须 catch 异常。

### 2.3 Styling (Tailwind v4)

-  **❌ No CSS Files**: 严禁创建 `.css`, `.scss`, `.less` 文件（`globals.css` 除外）。
-  **✅ Shadcn UI First**: 优先复用 `shadcn/ui` 组件。严禁手写 `div` 模拟按钮。
-  **✅ Responsive**: 必须使用 Tailwind 前缀 (`md:`, `lg:`)，严禁 JS 判断窗口宽度。

### 2.4 State Management (Zustand & Query)

-  **✅ Zustand**: 仅用于 **纯 UI 状态**（Sidebar 开关、Theme、Modal）。
-  **✅ TanStack Query**: 全权接管 **服务端数据**（Caching, Loading, Refetching）。严禁将 API 数据存入 Zustand。

### 2.5 Data Layer (Prisma & Zod)

-  **✅ Schema First**: 数据库变更必须先修改 `schema.prisma`。
-  **✅ Zod Validation**: 前端表单、Server Action 输入必须共用同一个 Zod Schema。严禁使用 `any`。

---